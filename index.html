<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0" />
<title>NFT Checker — Node Runner (ETH) / Alpha, Beta, Gamma, Delta (Base)</title>
<style>
  :root { --bg:#0f1115; --card:#141825; --bd:#22283a; --txt:#e7e9ee; --muted:#a6adbb; }
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;background:var(--bg);color:var(--txt);margin:0}
  header{padding:18px 16px;text-align:center;border-bottom:1px solid #1e2230}
  .row{display:flex;justify-content:center;gap:8px;flex-wrap:wrap}
  input,button{padding:10px 12px;font-size:16px;border-radius:10px;border:1px solid #2a3042;background:var(--card);color:var(--txt)}
  button{cursor:pointer}
  .hint{width:100%;text-align:center;font-size:12px;color:var(--muted);margin-top:6px}
  main{max-width:1200px;margin:0 auto;padding:16px}
  h2{margin:24px 0 12px;font-size:20px;font-weight:700}
  .grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(200px,1fr));gap:12px}
  .card{background:var(--card);border:1px solid var(--bd);border-radius:12px;overflow:hidden;text-align:center}
  .thumbs{padding:10px;min-height:84px;display:flex;justify-content:center;align-items:center}
  .thumbs img{width:100px;height:100px;object-fit:cover;border-radius:8px;background:#0b0e16}
  .meta{padding:10px;border-top:1px solid var(--bd)}
  .ok{color:#7CFC98;font-weight:700}
  .no{color:#ff6b6b;font-weight:700}
  .muted{color:var(--muted)}
  .status{margin-top:10px;text-align:center;opacity:.9}
</style>
</head>
<body>
<header>
  <div class="row">
    <input id="address" placeholder="Wallet address (0x…)" size="46" />
    <button id="goBtn">Check</button>
    <div class="hint">Your newly minted NFTs should appear within about 3–5 minutes.</div>
  </div>
  <div id="status" class="status"></div>
</header>

<main>
  <section>
    <h2>Node Runner — Ethereum</h2>
    <div id="grid-node-eth" class="grid"></div>
    <div id="status-node-eth" class="status muted"></div>
  </section>

  <section>
    <h2>Alpha — Base</h2>
    <div id="grid-alpha-base" class="grid"></div>
    <div id="status-alpha-base" class="status muted"></div>
  </section>

  <section>
    <h2>Beta — Base</h2>
    <div id="grid-beta-base" class="grid"></div>
    <div id="status-beta-base" class="status muted"></div>
  </section>

  <section>
    <h2>Gamma — Base</h2>
    <div id="grid-gamma-base" class="grid"></div>
    <div id="status-gamma-base" class="status muted"></div>
  </section>

  <section>
    <h2>Delta — Base</h2>
    <div id="grid-delta-base" class="grid"></div>
    <div id="status-delta-base" class="status muted"></div>
  </section>
</main>

<!-- ethers.js for on-chain fallback -->
<script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>

<script>
const COVALENT_KEY = "cqt_rQmpdjRkVtvctfYTqQ63mBKq3GWr";
const RPC = {
  1:    "https://ethereum.publicnode.com",
  8453: "https://mainnet.base.org",
};

/* Targets (fixed Delta last id = 4) */
const TARGETS = [
  // Node Runner — Ethereum (chainId:1)
  { group:"node",  chainId:1,    contract:"0xde63b92033aa77b115db1cec612029625d1c8fa5", tokenId:"0" },
  { group:"node",  chainId:1,    contract:"0xde63b92033aa77b115db1cec612029625d1c8fa5", tokenId:"1" },
  { group:"node",  chainId:1,    contract:"0xde63b92033aa77b115db1cec612029625d1c8fa5", tokenId:"2" },
  { group:"node",  chainId:1,    contract:"0xde63b92033aa77b115db1cec612029625d1c8fa5", tokenId:"3" },
  { group:"node",  chainId:1,    contract:"0xde63b92033aa77b115db1cec612029625d1c8fa5", tokenId:"4" },

  // Alpha — Base (chainId:8453)
  { group:"alpha", chainId:8453, contract:"0x307d51ad986d249f0b69a78c92ae2a6c140c19a4", tokenId:"0" },
  { group:"alpha", chainId:8453, contract:"0x307d51ad986d249f0b69a78c92ae2a6c140c19a4", tokenId:"1" },
  { group:"alpha", chainId:8453, contract:"0x307d51ad986d249f0b69a78c92ae2a6c140c19a4", tokenId:"2" },
  { group:"alpha", chainId:8453, contract:"0x307d51ad986d249f0b69a78c92ae2a6c140c19a4", tokenId:"3" },
  { group:"alpha", chainId:8453, contract:"0xe6cd37ef5f27dba134adc081ab9890193520e97a", tokenId:"4" },

  // Beta — Base (chainId:8453)
  { group:"beta",  chainId:8453, contract:"0xe6cd37ef5f27dba134adc081ab9890193520e97a", tokenId:"0" },
  { group:"beta",  chainId:8453, contract:"0xe6cd37ef5f27dba134adc081ab9890193520e97a", tokenId:"1" },
  { group:"beta",  chainId:8453, contract:"0xe6cd37ef5f27dba134adc081ab9890193520e97a", tokenId:"2" },
  { group:"beta",  chainId:8453, contract:"0xe6cd37ef5f27dba134adc081ab9890193520e97a", tokenId:"3" },

  // Gamma — Base (chainId:8453)
  { group:"gamma", chainId:8453, contract:"0x6f0df43e2849775e98350bc56ffa13e93b284a66", tokenId:"0" },
  { group:"gamma", chainId:8453, contract:"0x6f0df43e2849775e98350bc56ffa13e93b284a66", tokenId:"1" },
  { group:"gamma", chainId:8453, contract:"0x6f0df43e2849775e98350bc56ffa13e93b284a66", tokenId:"2" },
  { group:"gamma", chainId:8453, contract:"0x6f0df43e2849775e98350bc56ffa13e93b284a66", tokenId:"3" },
  { group:"gamma", chainId:8453, contract:"0x6f0df43e2849775e98350bc56ffa13e93b284a66", tokenId:"4" },

  // Delta — Base (chainId:8453)
  { group:"delta", chainId:8453, contract:"0x27b43b897ff89a1c9999e317304e756133beb105", tokenId:"0" },
  { group:"delta", chainId:8453, contract:"0x27b43b897ff89a1c9999e317304e756133beb105", tokenId:"1" },
  { group:"delta", chainId:8453, contract:"0x27b43b897ff89a1c9999e317304e756133beb105", tokenId:"2" },
  { group:"delta", chainId:8453, contract:"0x27b43b897ff89a1c9999e317304e756133beb105", tokenId:"3" },
  { group:"delta", chainId:8453, contract:"0x27b43b897ff89a1c9999e317304e756133beb105", tokenId:"4" },
];

/* helpers */
function toHttpFromIpfs(url){
  if(!url) return "";
  if(url.startsWith("ipfs://")) return `https://ipfs.io/ipfs/${url.replace("ipfs://","")}`;
  if(/^\/?ipfs\//i.test(url)) return "https://ipfs.io/" + url.replace(/^\/?/,"");
  return url;
}
function tidyId(x){
  const n = Number(String(x).replace(/^0+/, "")); // "0003"->3
  return Number.isFinite(n) ? String(n) : String(x);
}

/* Covalent (with single retry + soft error) */
async function fetchBalances(chainId, address){
  const url = `https://api.covalenthq.com/v1/${chainId}/address/${address}/balances_v2/?nft=true&no-nft-fetch=false`;
  for (let attempt=1; attempt<=2; attempt++){
    const res = await fetch(url, { headers: { Authorization: `Bearer ${COVALENT_KEY}` }});
    if (res.ok) return res.json();
    // retry on 429/5xx once
    if (attempt===1 && (res.status===429 || res.status>=500)) {
      await new Promise(r=>setTimeout(r, 800));
      continue;
    }
    // soft-fail: return empty items so UI can still render
    return { data:{ items:[] }, _error:{ status:res.status, body: await res.text().catch(()=>"") } };
  }
}

/* Build owned map from Covalent */
function buildOwnedTokenMap(data){
  const map = {};
  const items = (data?.data?.items || []).filter(x => x.type === "nft" && Array.isArray(x.nft_data));
  for(const col of items){
    const c = (col.contract_address || "").toLowerCase();
    if(!c) continue;
    if(!map[c]) map[c] = {};
    for(const nft of col.nft_data){
      const tid = tidyId(nft.token_id ?? "");
      const meta = nft.external_data || {};
      const img = toHttpFromIpfs(meta.image || "");
      const fallbackName = `${col.contract_name || "NFT"} #${tid}`;
      map[c][tid] = { img, name: meta.name || fallbackName, collection: col.contract_name || "NFT" };
    }
  }
  return map;
}

/* ---- On-chain fallback (public RPC, no rate limit) ---- */
function getProvider(chainId){ return new ethers.providers.JsonRpcProvider(RPC[chainId]); }

async function detectOwnership(chainId, contract, tokenId, address){
  try{
    const provider = getProvider(chainId);
    const ca = new ethers.Contract(contract, [
      "function ownerOf(uint256) view returns (address)",                // ERC721
      "function balanceOf(address,uint256) view returns (uint256)",     // ERC1155
    ], provider);

    // try ERC721
    try{
      const owner = await ca.ownerOf(ethers.BigNumber.from(tokenId));
      if (owner && owner.toLowerCase() === address.toLowerCase()) return true;
    } catch(_) { /* not ERC721 or not minted */ }

    // try ERC1155
    try{
      const bal = await ca.balanceOf(address, ethers.BigNumber.from(tokenId));
      return bal && bal.toString() !== "0";
    } catch(_) {}

    return false;
  }catch(e){ console.warn("detectOwnership error", e); return false; }
}

/* tokenURI/uri → metadata json */
async function fetchMetadataOnChain(chainId, contract, tokenId){
  try{
    const provider = getProvider(chainId);
    const ca = new ethers.Contract(contract, [
      "function tokenURI(uint256) view returns (string)",
      "function uri(uint256) view returns (string)"
    ], provider);

    let uri;
    // ERC721 tokenURI
    try{ uri = await ca.tokenURI(ethers.BigNumber.from(tokenId)); } catch(_) {}
    // ERC1155 uri (may contain {id})
    if(!uri){
      try{ uri = await ca.uri(ethers.BigNumber.from(tokenId)); } catch(_) {}
    }
    if(!uri) return null;

    // handle {id} placeholder (ERC1155 → hex64)
    if (uri.includes("{id}")){
      let hex = Number(tokenId).toString(16);
      hex = hex.padStart(64, "0");
      uri = uri.replace(/\{id\}/g, hex);
    }
    const http = toHttpFromIpfs(uri);
    const res = await fetch(http);
    if(!res.ok) return null;
    const j = await res.json().catch(()=>null);
    if(!j) return null;
    const img = toHttpFromIpfs(j.image || j.image_url || "");
    const name = j.name || "";
    return { img, name };
  }catch(e){ console.warn("fetchMetadataOnChain error", e); return null; }
}

/* single metadata via Covalent (cached) */
const META_CACHE = new Map(); // `${chainId}:${contract}:${tokenId}`
async function fetchSingleMetadata(chainId, contract, tokenId){
  const key = `${chainId}:${contract.toLowerCase()}:${tokenId}`;
  if(META_CACHE.has(key)) return META_CACHE.get(key);

  const url = `https://api.covalenthq.com/v1/${chainId}/tokens/${contract}/nft_metadata/${tokenId}/`;
  const res = await fetch(url, { headers: { Authorization: `Bearer ${COVALENT_KEY}` }});
  if(!res.ok){ META_CACHE.set(key, null); return null; }
  const json = await res.json();
  const item  = json?.data?.items?.[0];
  const nd    = item?.nft_data?.[0];
  const ed    = nd?.external_data || {};
  const img   = toHttpFromIpfs(ed.image || "");
  const collection = item?.contract_name || "NFT";
  const name  = ed.name || `${collection} #${tokenId}`;
  const out = { img, name, collection };
  META_CACHE.set(key, out);
  return out;
}

/* render (Covalent → fallback to on-chain if needed) */
async function renderTargets({targets, ownedMap, gridEl}){
  gridEl.innerHTML = "";

  const cards = await Promise.all(targets.map(async t => {
    const cLower = t.contract.toLowerCase();
    const tid = tidyId(t.tokenId);
    const displayId = (Number(tid) + 1);

    // First try Covalent ownership
    let owned = !!(ownedMap[cLower] && ownedMap[cLower][tid]);
    let img = "", titleName = "NFT";

    // Prefer Covalent metadata if available
    if(owned){
      const m = ownedMap[cLower][tid];
      img = m?.img || "";
      titleName = m?.collection || "NFT";
      // If collection looks generic, optionally enrich later
    }

    // If Covalent didn’t confirm OR title still generic => on-chain fallback for Base/ETH
    if (!owned || !titleName || /^nft$/i.test(titleName)){
      // Only hit chain when needed (slower)
      const addr = document.getElementById('address').value.trim().toLowerCase();
      const ocOwned = await detectOwnership(t.chainId, t.contract, tid, addr);
      if (ocOwned) owned = true;

      // Try on-chain metadata (tokenURI/uri)
      const ocMeta = await fetchMetadataOnChain(t.chainId, t.contract, tid);
      if (ocMeta){
        if (!img && ocMeta.img) img = ocMeta.img;
        if (ocMeta.name){
          // Use collection-like title if name contains a # already; else keep generic contract name from Covalent later
          titleName = ocMeta.name.replace(/\s*#\d+$/,""); // strip trailing #num if present
        }
      }

      // If still no collection title, try Covalent single metadata as last resort
      if (!img || /^nft$/i.test(titleName) || !titleName){
        const co = await fetchSingleMetadata(t.chainId, t.contract, tid);
        if (co){
          if (!img && co.img) img = co.img;
          if (!titleName || /^nft$/i.test(titleName)) titleName = co.collection || "NFT";
        }
      }
    }

    const card = document.createElement("div");
    card.className = "card";

    const thumbs = document.createElement("div");
    thumbs.className = "thumbs";
    if(img){
      const el = document.createElement("img");
      el.src = img; el.alt = `${titleName} #${displayId}`; el.loading = "lazy";
      thumbs.appendChild(el);
    } else {
      thumbs.innerHTML = `<div class="muted">(No preview)</div>`;
    }

    const info = document.createElement("div");
    info.className = "meta";
    info.innerHTML = `
      <div style="font-weight:700;font-size:15px;margin-bottom:4px">
        ${titleName || "NFT"} — #${displayId}
      </div>
      <div class="${owned?'ok':'no'}">${owned?'You have':'Missing'}</div>
    `;

    card.appendChild(thumbs);
    card.appendChild(info);
    return card;
  }));

  for(const c of cards) gridEl.appendChild(c);
}

/* flow */
async function checkAll(){
  const addr = document.getElementById('address').value.trim();
  const status = document.getElementById('status');

  const gridNodeEth   = document.getElementById('grid-node-eth');
  const gridAlphaBase = document.getElementById('grid-alpha-base');
  const gridBetaBase  = document.getElementById('grid-beta-base');
  const gridGammaBase = document.getElementById('grid-gamma-base');
  const gridDeltaBase = document.getElementById('grid-delta-base');

  const statusNodeEth   = document.getElementById('status-node-eth');
  const statusAlphaBase = document.getElementById('status-alpha-base');
  const statusBetaBase  = document.getElementById('status-beta-base');
  const statusGammaBase = document.getElementById('status-gamma-base');
  const statusDeltaBase = document.getElementById('status-delta-base');

  gridNodeEth.innerHTML=gridAlphaBase.innerHTML=gridBetaBase.innerHTML=gridGammaBase.innerHTML=gridDeltaBase.innerHTML="";
  statusNodeEth.textContent=statusAlphaBase.textContent=statusBetaBase.textContent=statusGammaBase.textContent=statusDeltaBase.textContent="";
  status.textContent="";

  if(!/^0x[a-fA-F0-9]{40}$/.test(addr)){ alert("Please enter a valid 0x address."); return; }

  const nodeTargets  = TARGETS.filter(t => t.group==="node");
  const alphaTargets = TARGETS.filter(t => t.group==="alpha");
  const betaTargets  = TARGETS.filter(t => t.group==="beta");
  const gammaTargets = TARGETS.filter(t => t.group==="gamma");
  const deltaTargets = TARGETS.filter(t => t.group==="delta");

  status.textContent = "Loading…";

  try{
    const wantsEth  = nodeTargets.length>0;
    const wantsBase = (alphaTargets.length+betaTargets.length+gammaTargets.length+deltaTargets.length)>0;

    const [ethRes, baseRes] = await Promise.allSettled([
      wantsEth  ? fetchBalances(1, addr)     : Promise.resolve(null),
      wantsBase ? fetchBalances(8453, addr)  : Promise.resolve(null)
    ]);

    if(wantsEth && ethRes.status==="fulfilled"){
      const mapEth = buildOwnedTokenMap(ethRes.value);
      await renderTargets({targets: nodeTargets, ownedMap: mapEth, gridEl: gridNodeEth});
    } else if (wantsEth){
      const empty = {};
      await renderTargets({targets: nodeTargets, ownedMap: empty, gridEl: gridNodeEth}); // on-chain fallback will kick in
      statusNodeEth.textContent = "Ethereum API issue — using on-chain fallback.";
    }

    if(wantsBase){
      if (baseRes.status==="fulfilled"){
        const mapBase = buildOwnedTokenMap(baseRes.value);
        await renderTargets({targets: alphaTargets, ownedMap: mapBase, gridEl: gridAlphaBase});
        await renderTargets({targets: betaTargets,  ownedMap: mapBase, gridEl: gridBetaBase});
        await renderTargets({targets: gammaTargets, ownedMap: mapBase, gridEl: gridGammaBase});
        await renderTargets({targets: deltaTargets, ownedMap: mapBase, gridEl: gridDeltaBase});
        if (baseRes.value?._error){
          statusAlphaBase.textContent = `Base API returned ${baseRes.value._error.status}. Using on-chain fallback where needed.`;
        }
      } else {
        // complete Covalent failure → on-chain fallback only
        const empty = {};
        await renderTargets({targets: alphaTargets, ownedMap: empty, gridEl: gridAlphaBase});
        await renderTargets({targets: betaTargets,  ownedMap: empty, gridEl: gridBetaBase});
        await renderTargets({targets: gammaTargets, ownedMap: empty, gridEl: gridGammaBase});
        await renderTargets({targets: deltaTargets, ownedMap: empty, gridEl: gridDeltaBase});
        statusAlphaBase.textContent = "Base API error — using on-chain fallback.";
      }
    }

    status.textContent = "";
  }catch(e){
    console.error(e);
    status.innerHTML = `<span class="no">Error: ${e.message}</span>`;
  }
}

document.getElementById('goBtn').addEventListener('click', checkAll);
</script>
</body>
</html>
